\chaptersub{Symmetric Modes}{Private Key Cryptography}

\section{Block Ciphers}
    A \textbf{block cipher} is type of encryption based on \textbf{permutation}, where they key, $\{0,1\}^k$, defines a transposition of bits in the block to the encrypted, $\{0,1\}^b$. The block is a proportion of the message.\\
    \\
    DES was the first civilian block cipher and was developed at IBM in the 1970s. When the US government adopted it, they recommended the following four ways to use it, these are now used with any block cipher.
    \begin{itemize}
        \item Electronic Code Book
        \item Cipher Block Chaining
        \item Counter
        \item ...
    \end{itemize}
    
    \subsection{Electronic Code Book}
    This is a very simple, it \textbf{divides} the message into blocks of size $b$, pads the last one, and \textbf{encrypts them all individually}. A block cipher using ECB is only OW-CPA, as Figure~\ref{fig:ecb-attacktable} says. This the terrible!\\
    \begin{figure}[htp!]
    \centering
    \attacktable{owcpa}
    \caption{Security Models ECB passes}
    \label{fig:ecb-attacktable}
    \end{figure}
    \\
    The weakness of this mode is in the fact that the blocks of encrypted independently. This is the basis for the two attacks below, but it also means it's susceptible to \textbf{block replay}. That is where an adversary edits a bit knowing how it will affect the decrypted message. If I knew you were sending me some money, and I knew the block containing the amount you were transferring, I could change that block in the hope I would end up with a larger transaction. This could be fixed with a checksum. ECB has one positive that an error in the cipher text will not propagate to other blocks when decrypted.\\
    \\
    \textbf{Proving a cryptographic system passes a security model is beyond this scope of this course}, but you should be able to give an intuitive reason. It passes OW-CPA because, with only an encryption oracle, you would have to brute-force every possible message to match it with the ciphertext. We can always make $b$ large enough so that this is not possible.\footnote{This might be possible if you knew the context of the message, if you understand what is being sent and the domain of possible values of a block is relatively small. This is simply poor implementation of the encryption, however, and we don't worry about that.}\\
    \\
    \textbf{OW-CCA Example:} We can win an OW-CCA game by kind of cheating in the following way. If we have a decryption oracle, we can decrypt anything that is not the message. Since the blocks are independent, we can simply split the message in half and decrypt both individually and then concatenate the result.\\
    \\
    \textbf{IND-PASS Example:} In an Indistinguishability game we decide the message (of which one will be encrypted). Again we use the fact that the blocks are encrypted independently, and give one of the message as a bit string concatenated onto itself, $m_0=b_1||b_1$. The ciphertext can be split into two equal bit strings in the same way, then it was that message.
    
    
    
    \subsection{Cipher Block Chaining}
    Cipher Block Chaining removes a lot of the problems with the ECB by XORing each block with the previously encrypted block --- incorporating a dependence on the previous block. The first block of the ciphertext is called the \textbf{Initalisation Vector} (IV), and is what the first block of the message is XOR-ed with.\\
    \begin{figure}[htp!]
        \centering
        \includegraphics[width=10cm]{img/cbc}
        \caption{Diagram of CBC encrypting}
    \end{figure}
    \\
    More formally:\nopagebreak
    \begin{center}
    \begin{tabular}{lll}
    \textbf{Encryption}:                                        && \textbf{Decryption}\\
    $c_0 = IV$                                                  && $IV = c_0$\\
    $c_1 = Enc_k(m_1 \oplus IV)$                                && $m_1 = Dec_k(c_1) \oplus IV$\\
    $c_i = Enc_k(m_i \oplus c_{i-1}) \textrm{ for } i > 1$      && $m_i = Dec_k(c_i) \oplus c_{i-1} \textrm{ for } i > 1$\\
    \end{tabular}
    \end{center}
    \begin{figure}[htp!]
        \centering
        \attacktable{indcpa}
        \caption{Security of Models CBC}
        \label{fig:cbc-attacktable}
    \end{figure}
    Note that $IV$ is sent unencrypted, because it is needed for decryption. This can seem pointless, but if it is generated randomly every time, then it means that encryption is probabilistic. CBC is OW-CPA and IND-CPA but not OW-CCA or IND-CCA.\\
    \begin{figure}[htp!]
        \centering
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \includegraphics[width=\textwidth]{img/Tux.jpg}
            \caption{Original Image\\~}
        \end{subfigure}
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \includegraphics[width=\textwidth]{img/Tux_ecb.jpg}
            \caption{Encrypted using ECB\\~}
        \end{subfigure}
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \includegraphics[width=\textwidth]{img/Tux_secure.jpg}
            \caption{Encrypted using Chaining}
        \end{subfigure}
        \caption{Bitmap image of Tux being encrypted using ECB and using another method that uses chaining.}
        \label{fig:tux}
    \end{figure}
    \\
    \textbf{With a decryption oracle, CBC will fail} because of the same trick used before --- we can ask to oracle to decrypt the ciphertext with extra blocks on the end.
    
    
    
    \subsection{Counter Mode}
    Counter mode is the same as CBC mode, but 

\section{Message Authentication}
    \subsection{Why Do This}
        Encrypting data provides confidentiality (remember the three goals), but does not provide authenticity or integrity without additional sauce. This is the additional sauce.
        It comes with two flavours that are used for different things: \textbf{MDC} (Manipulation Detection Codes) and \textbf{MAC} (Message Authentication Codes). We will worry about \textbf{MAC} as MDC isn't in the exam.
        The reason we use these at all is that they are the secret ingredient in getting from IND-CPA to the mythical, coveted IND-CCA level of security.


    \subsection{\textbf{M}essage \textbf{A}uthentication \textbf{C}odes}
    MAC codes are the result of hashing the message, using a hash function that takes a key.
    \begin{figure}[htp!]
        \centering
        MAC = $h_{k}(m)$
    \end{figure}

    You would then typically send the MAC concatenated at the end of the message. The hash function, as per Kerckhoff's principle, is publicly described. Given \emph{k} and \emph{m}, computing $h_{k}(m)$ should be easy.
    Given only \emph{m}, computing a correct hash should be very difficult, even if several message-to-hash pairs are already known.

    A hash function is simply a surjective mapping from arbritrarily long strings to fixed length hash strings. 

    \subsection{Security Model}
    Our security models are simple:
    \begin{itemize}
        \item \textbf{EF-PASS}: The passive attack where the bad guy can generate a valid MAC for any message, gibberish or otherwise. 
        `Existential' forgery is where the message may just be random rubbish, `Selective' forgery is creating a MAC for a specific message.

        \item \textbf{EF-CMA}: As above, but the douche of an adversary has an oracle that can perform MAC generation on other messages of his choice (but not the target message). This is the `Chosen Message' Attack
    \end{itemize}

    We will now look at two games for Existential Forgery; as a MAC may be probabilistic, we define two algorithms for these games:

    \begin{itemize}
        \item $\textbf{MAC}_{k}(m)$: Generates the MAC for message \emph{m}.
        \item $V_{k}(m, c)$: A boolean-returning verification function. True is good. False is bad. Get with the program, kids. Also this may not simply be a case of recomputing the MAC; if the algorithm that generates it is probabilistic, we need other methods of checking correctness.
    \end{itemize}

    It is a given that our opponent has access to a Verification Oracle (otherwise how will they know if they have cracked it?). 

    \begin{figure}[htp!]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \begin{cryptogame}{}
            \cgameright{$V(m, c)$}
            \cgameleft{$m^{*}$, $c^{*}$}
        \end{cryptogame}
        \caption{EF-PASS: Passive Attack}
        \label{fig:ef-pass}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \begin{cryptogame}{}
            \cgameright{$V(m, c)$}
            \cgameright{$c = MAC_{k}(m)$}
            \cgameleft{$m^{*}$, $c^{*}$}
        \end{cryptogame}
        \caption{EF-CMA: Chosen Message Attack}
        \label{fig:ef-cma}
    \end{subfigure}
    \caption{MAC security games}
    \label{fig:ef-games}
\end{figure}

    There exists a `Strong Forgery' variant of \textbf{EF-CMA} called, unsuprisingly, \textbf{SF-CMA}, which changes the restriction on the MAC oracle to be that whilst $m^{*}$ can be passed to the oracle, $c^{*}$ must not have been returned.

    Assuming we can create a MAC function that achieves this, we can now make INC-CCA symmetric encryption schemes! Hooray!

\section{IND-CCA Here We Come}
    \subsection{Making A Scheme}
    The reason that CBC and CTR modes, whilst groovy, were not \textbf{IND-CCA} was that an attacker could look at our ciphertext and construct a related one which could be decrypted through their oracle, giving them a related plaintext.

    MAC prevents them from doing that! Sweet! So to make an \textbf{IND-CCA} secure scheme you will need:
    \begin{itemize}
        \item One \textbf{IND-CPA} secure symmetric cipher \emph{E}.
        \item One \emph{SECURE}\footnote{i.e. Cannot produce a valid \textbf{MAC} without access to the correct key} \textbf{MAC} function \emph{MAC}.
        \item One hybrid key consisting of $k_{0}$ and $k_{1}$ which are the keys for \emph{E} and \emph{MAC} respectively.
    \end{itemize}

    We can then construct encryption and decryption thusly:
    \begin{figure}[htp!]
    \centering
    \raisebox{-0.5\height}{
        \begin{subfigure}[b]{0.4\textwidth}
            \centering
            \textbf{Encrypt}
            \begin{enumerate}
                \item Split $k$ into $k_{0}$ and $k_{1}$
                \item $c_{0} = E_{k_{0}}(m)$
                \item $c_{1} = MAC_{k_{1}}(c_{0})$
                \item And voila: $c = (c_{0}, c_{1})$
            \end{enumerate}
            \label{fig:ind-cca-enc}
        \end{subfigure}
        }
    ~
    \raisebox{-0.5\height}{
        \begin{subfigure}[b]{0.4\textwidth}
            \centering
            \textbf{Decrypt}
            \begin{enumerate}
                \item Split $k$ into $k_{0}$ and $k_{1}$
                \item Split $c$ into $c_{0}$ and $c_{1}$
                \item $c_{1}^{*} = MAC_{k_{1}}(c_{0})$
                \item If $c_{1}^{*} \neq c_{1}$ then ABORT and return $\bot$
                \item Else return $m$ where $m = D_{k_{0}}(c_{0})$ 
            \end{enumerate}
            \label{fig:ind-cca-dec}
        \end{subfigure}
    }
    \caption{How To Make an IND-CCA Scheme}
    \label{fig:ind-cca-ed}
    \end{figure}