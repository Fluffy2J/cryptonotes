\documentclass[oneside,a4paper,12pt]{book}

\usepackage[margin=1in]{geometry}
\usepackage{titlesec}
\usepackage{lipsum} 
\usepackage{xcolor} 

\usepackage{tikz}
\usepackage{subcaption}
\usepackage{ifthen}
\usepackage{tabularx}

\usepackage{fancyhdr}
\usepackage{lastpage}

\usepackage{fixltx2e}

\usepackage{amsmath}
\usepackage{amssymb}


\definecolor{R}{RGB}{220,20,60}
\definecolor{B}{RGB}{39,64,139}
\definecolor{G}{RGB}{0,139,69}
\definecolor{orange}{rgb}{1,0.5,0}

\usepackage{hyperref}
\hypersetup{linktocpage}

\begin{document}

\pagestyle{fancy}
\lhead{\footnotesize \parbox{11cm}{Cryptography Notes} }
\lfoot{\footnotesize \parbox{11cm}{Shared}}
\cfoot{}
\rhead{\footnotesize Lecture Notes}
\rfoot{\footnotesize Page \thepage\ of \pageref{LastPage}}
\renewcommand{\headheight}{24pt}
\renewcommand{\footrulewidth}{0.4pt}

\titleformat{\chapter}[display]
  {\normalfont\normalsize\bfseries\LARGE}
  {\chaptertitlename~\thechapter}{1pc}
  {{\color{brown}\titlerule[2pt]}\vspace{1pc}\MakeUppercase}
    \titleformat{name=\chapter,numberless}[display]
  {\normalfont\normalsize\bfseries\LARGE}{}{1pc}
  {\MakeUppercase}
  
  
  
\newcounter{cryptogamearrows}
\newenvironment{cryptogame}[1]{
    \setcounter{cryptogamearrows}{0}
    \begin{center}
        \begin{tikzpicture}
            \node at (-1,0.75) {#1};
}{
            \draw [thick] (0.6,0.1) rectangle (1.9,0.35-0.5*\arabic{cryptogamearrows});
            \node at (1.25,0.2-0.25*\arabic{cryptogamearrows}) {\textbf{A}};
        \end{tikzpicture}
    \end{center}
}
\newcommand{\cgamearrow}[2]{\node [left] at (0,0-0.5*\arabic{cryptogamearrows}) {#1};\draw [thick][#2] (0,0-0.5*\arabic{cryptogamearrows}) -- (0.5,0-0.5*\arabic{cryptogamearrows});\stepcounter{cryptogamearrows}}
\newcommand{\cgameright}[1]{\cgamearrow{#1}{->}}
\newcommand{\cgameleft}[1]{\cgamearrow{#1}{<-}}  

\newcommand{\cbox}[2]{\begin{tikzpicture}\node [rectangle, draw, fill=#1, text centered, rounded corners] {#2};\end{tikzpicture}}
\newcommand{\gbox}[1]{\cbox{blue!20}{#1}}

\newcommand{\boldcbox}[2]{\begin{tikzpicture}\node [rectangle, draw, thick, fill=#1, text centered, rounded corners] {\textbf{#2}};\end{tikzpicture}}

\newboolean{indcca}\newboolean{indcpa}\newboolean{indpass}
\newboolean{owcca}\newboolean{owcpa}\newboolean{owpass}

\newcommand{\clearattackcolours}{
    \setboolean{indcca}{false}\setboolean{indcpa}{false}\setboolean{indpass}{false}
    \setboolean{owcca}{false}\setboolean{owcpa}{false}\setboolean{owpass}{false}
}

\newcommand{\comment}[1]{}
\newcommand{\attackpasscolour}{green}
\newcommand{\ttackfailcolour}{red!80}
\newcommand{\condbox}[3]{\ifthenelse{ \equal{#1}{#3}
                            }{
                                \ifthenelse{\boolean{#1}}{\boldcbox{\attackpasscolour}{#2}}{\bold{\ttackfailcolour}{#2}}
                            }{
                                \ifthenelse{\boolean{#1}}{\cbox{\attackpasscolour}{#2}}{\cbox{\ttackfailcolour}{#2}}
                            }
                        }

\newcommand{\attacktable}[1]{
    \clearattackcolours
    \setboolean{#1}{true}
    \ifthenelse{\boolean{indcca}}{\setboolean{indcpa}{true}}{}
    \ifthenelse{\boolean{indcpa}}{\setboolean{indpass}{true}}{}
    \ifthenelse{\boolean{indcca}}{\setboolean{owcca}{true}}{}
    \ifthenelse{\boolean{indcpa} \OR \boolean{owcca}}{\setboolean{owcpa}{true}}{}
    \ifthenelse{\boolean{indpass} \OR \boolean{owcpa}}{\setboolean{owpass}{true}}{}
    \begin{tabular}{ccccc}
        \condbox{indcca}{IND-CCA}{#1} & $\rightarrow$ & \condbox{indcpa}{IND-CPA}{#1} & $\rightarrow$ & \condbox{indpass}{IND-PASS}{#1}\\
        $\downarrow$ && $\downarrow$ && $\downarrow$ \\
        \condbox{owcca}{OW-CCA}{#1} & $\rightarrow$ & \condbox{owcpa}{OW-CPA}{#1} & $\rightarrow$ & \condbox{owpass}{OW-PASS}{#1}\\
    \end{tabular}
}

\newcommand{\attacktabletwo}[2]{
    \clearattackcolours
    \setboolean{#1}{true}
    \setboolean{#2}{true}
    \ifthenelse{\boolean{indcca}}{\setboolean{indcpa}{true}}{}
    \ifthenelse{\boolean{indcpa}}{\setboolean{indpass}{true}}{}
    \ifthenelse{\boolean{indcca}}{\setboolean{owcca}{true}}{}
    \ifthenelse{\boolean{indcpa} \OR \boolean{owcca}}{\setboolean{owcpa}{true}}{}
    \ifthenelse{\boolean{indpass} \OR \boolean{owcpa}}{\setboolean{owpass}{true}}{}
    \begin{tabular}{ccccc}
        \condbox{indcca}{IND-CCA}{#1} & $\rightarrow$ & \condbox{indcpa}{IND-CPA}{#1} & $\rightarrow$ & \condbox{indpass}{IND-PASS}{#1}\\
        $\downarrow$ && $\downarrow$ && $\downarrow$ \\
        \condbox{owcca}{OW-CCA}{#1} & $\rightarrow$ & \condbox{owcpa}{OW-CPA}{#1} & $\rightarrow$ & \condbox{owpass}{OW-PASS}{#1}\\
    \end{tabular}
}


\titleformat*{\paragraph}{\large\normalfont}

\title{Cryptography A\&B - Lecture Notes}
\author{Shared}
\date{\today}
\maketitle
\tableofcontents
\mainmatter
\part{Cryptography A}

\thispagestyle{fancy}
\lhead{\footnotesize \parbox{11cm}{Cryptography A} }
\lfoot{\footnotesize \parbox{11cm}{Vlad Otrocol}}
\cfoot{}
\rhead{\footnotesize Lecture Notes}
\rfoot{\footnotesize Page \thepage\ of \pageref{LastPage}}
\renewcommand{\headheight}{24pt}
\renewcommand{\footrulewidth}{0.4pt}

\newcommand{\chaptersub}[2]{\chapter[#1]{#1 \\ \large{\textit{#2}}}}

\input{chapters/introduction.tex}

\input{chapters/classiccrypto.tex}

\input{chapters/moderncrypto.tex}

\input{chapters/symmetricmodes.tex}

\input{chapters/assymmetricmodes.tex}









































\part{Cryptography B}

\chapter{Lecture 1}%1111111111111111111111111111111111111111111111111111111111111111111111

These brief lecture notes are intended to help you focus on the main concepts that we have covered in class. Their structure follows closely on that of the lectures. These notes are not a substitute for your own - they are not as comprehensive as they should be and may contain typos. Apart from these notes you should also read the respective chapters in Katz-Lindell (KL).

\section{Notation}

We write \begin{math}x \gets A(y)\end{math} to say that we obtain \textit{x} by running algorithm A on input \textit{y}. Notice that \textit{A} can be randomized, which is indicated as follows: \begin{math}x\xleftarrow{\$}A(y)\end{math}. In general if \textit{D} is a distribution we write \begin{math}x\xleftarrow{\$}D\end{math} to indicate that \textit{x} is sampled according to ditribution D. If \textit{S} is any finite set, we write \begin{math}x\gets S\end{math} to mean that we select \textit{x} uniformly at random from \textit{S}. If \textit{x} and \textit{y} are are strings, then we write \begin{math}x||y\end{math} for the concatenation of \textit{x} with \textit{y}.

\section{Security Models}


In the early days of cryptography, the design of cryptographic systems used a trial-and error approach: first design the system, then wait for someone to break it, then patch it, wait for another break and so on, until no more attacks can be found. Unfortunately this approach offers minimal security guarantees.

The defining characteristic of modern cryptography is that it uses \textit{security models} for defining the security of various primitives and protocols and perhaps more importantly, their use in \textit{proving security}. Next, we describe at high level what a security models is and then have a look at some examples.

Before being able to even define a security model, one has to fix(or set) the syntax of a primitive, that is, to specify precisely what are the algorithms that implement the primitive. A security model for a primitive then makes two things precise:

\begin{itemize}
\item The first thing that a security model for a primitive specifies is how an arbitrary adversary is allowed to interact with the primitive. This interaction should be as general as possible since it should reflect \textit{all} possible ways in which the primitive is going to be used when deployed.
\item The second issues thst the security model should specify is wehat is the adversary`s goal, in other words, what should be considered a break for the primitive.
\end{itemize}

We will describe several of the most common security models used in modern cryptography. How do we know that a secuurity model does indeed capture the security of the primitive? Unfortunately there is no good answer to this question. It may seem that security models suffer from the same problem as the first cryptosustems, however, in this case the situation is somewhat better: once validated, through inspection, usage, etc. they can be used to \textit{prove} the security of particular implementations. It still happens in cryptography that the models in use turn out not to be sufficiently precise because they do not capture all possible abilities that an adversary has or because it does not specify what a break is sufficiently well.

\section{Negligible Functions}

A function \textit{f}, is said to be negligible if it decreases faster than the inverse of any polynomial. Or, more formally, for any polynomial \textit{p} there exists some natural number \begin{math}n_0 \in \mathbb{N} \end{math} such that for all \begin{math} n\geq n_0\end{math} we have that:
\begin{align*}f(n) \leq \frac{1}{p(n)} \end{align*}

\section{Exercises}
\begin{enumerate}
\item Prove that if \textit{f(x)} is negligible then $c\times f(x)$ is also negligible, where c is a constant.
\item Prove that if \textit{f(x)} and \textit{g(x)} are negligible then \textit{f(x)+g(x)} is negligible too.
\end{enumerate}

\chapter{Lecture 2} %222222222222222222222222222222222222222222222222222222222222222

\section{One-Way-Functions(OWF)}

We were looking at the diagram in lecture one and asked the question: What would happen if RSA or Discrete Log are broken? What will we rely on then? The answer is that there are other hard problems out there for example: eliptic curves, factoring, lattice problems.

What is hard on those problems is distilled into one single concept: the One Way Function. What is great about this type of functions is that they are easy to compute but hard to invert (which means encryptions based on them are easy to compute but hard to break).

But how do we mathematically define the fact that this function is "easy to compute"? We say that a function is easy to compute if there is a poly-time algorithm that computes that function.

Now how do we define that it's hard to invert? We can informally state that as the probability of an adversary to find a pre-image for a given image of a random input is negligible.

The two properties above give us the definition of an OWF which is formally stated as follows:

A function \begin{math}f:\{0,1\}^*\leftarrow\{0,1\}^*\end{math} is an OWF if:
\begin{itemize}
\item \begin{math}\exists  M \text{, a poly time algorithm which computes } f\end{math}
\item    for any efficient adversary \textit{A},\\ \begin{math} Prob[y=f(z): x \xleftarrow{\$} \{0,1\}^n; y=f(x);z \xleftarrow{\$} A(y)] \text{
    \hspace{2mm}is a negligible function of }k\end{math}
\end{itemize}

Now let's try a couple of exercises:
\begin{itemize}

    \item Is the function \begin{math}f(x)=0\end{math} an OWF?
    
    \begin{itemize}
    
        \item Clearly this function is not reversible since we cannot recover \textit{x} given \textit{f(x)}. However,               given the image of \textit{f} on a random point we can easily find a pre-image by simply picking any $z \in \{0,1\}^*$  proving that this function is not an OWF.
        
    \end{itemize}
    
    \item Is the function \begin{math}f(x_1,x_2)=x_1\end{math} an OWF? Consider \begin{math}x=x_1||x_2\text{, } |x_1|=|x_2|\end{math}.
    
    \begin{itemize}
    
        \item Clearly this function is not reversible in the traditional sense, however, given $y=x_1=f(x_1,x_2)$ one can easily find a pre-image of $y$ by simply considering $x_1,0^{|x_1|}$ (where by $0^n$ we mean $0$ repeated $n$ times).
        
    \end{itemize}

    \item Is the function \begin{math}f(x_1,x_2)=x_1\oplus x_2\end{math} an OWF? This is ``One-Time Pad``.
    
    \begin{itemize}
    
        \item This function is not reversible either, however, given $y=x_1=f(x_1,x_2)$ one can easily find a pre-image of $y$ by simply considering $(x_1\oplus x_2)$ and $0^{|x_1\oplus x_2|}$ (where by $0^n$ we mean $0$ repeated $n$ times).
        
    \end{itemize}

    \item Is the function \begin{math}f(x_1,x_2)=x_1\times x_2\end{math} an OWF?
    
    \begin{itemize}
    
        \item The definition says that in order for a function to be a OWF, the probability of an adversary to find a pre-image must be a negligible function. In this case, in contrast to the ones above, the probability of finding a pre-image is not 1 anymore. This problem is based on the factoring problem. The probability of finding a factor is at least $\frac {1}{2}$ because of the number 2. However, if we choose our numbers to be large primes then this probability lowers considerably and it can get to the point when it is negligible, rendering the function \begin{math}f(x_1,x_2)=x_1\times x_2\end{math} an OWF.
        
    \end{itemize}
    
\end{itemize}
    
From the last example we conclude that \textit{``if Factorising is HARD then OWF is HARD``}.

\section{One-Time Signatures(OTS)}

Using OWFs we can build \textit{signatures} and \textit{symmetric encryption schemes}, but we cannot build \textit{public-key encryption}.\\

\textit{\textbf{Definition:} A signature scheme is a tuple of three probabilistic polynomial-time algorithms \textbf{(Gen, Sign, Verify)} satisfying the following:}
\begin{enumerate}
    \item The key-generation algorithm Gen takes as input a security parameter $1^n$ and outputs a pair of keys \textit{(pk,sk)}. These are called the public key(or the verification key - vk) and the private key, respectively. We assume for convenience that \textit{pk} and \textit{sk} each have length at least \textit{n} and that \textit{n} can be determined from \textit{pk,sk}.
    \item The signing algorithm \textit{Sign} takes as input the private key \textit{sk} and a message $m \in \{0,1\}^*$. It outputs a signature $\sigma$, denoted as $\sigma \gets Sign_{sk}(m)$.
    \item The deterministic verification algorithm \textit{Verify} takes as input a public key \textit{pk}, a message \textit{m} and a signature $\sigma$ and outputs a bit \textit{b}, with \textit{b} = 1 for valid and \textit{b}=0 for invalid. We write this as $b:=Verify(m,\sigma)$.
\end{enumerate}

$Verify(m, Sign(m)) = 1$ - the message m is authentic.\\

Now we shall construct a \textit{One-Time Signature} using OWFs.\\

\textit{\textbf{Theorem:} If $\exists \text{OWF} \text{ then } \exists \text{OTSs(One-time Signatures)}$}.
\newpage
In order to define the security of a signature scheme we build a game:
\begin{itemize}
\item The key generation algorithm outputs a public key (pk) and a private key (sk).
\item The adversary A gets the public key (pk)
\item The signing oracle receives the private key(sk) from Gen and the message m
\item The adversary A sends a message m to the signing oracle.
\item The signing oracle outputs a signature $\sigma$
\end{itemize}

What does it mean for A to produce a forgery?

\textbf{Definition} A forgery in a signature scheme has been produced if an adversary manages to find a message $m^*$ different from the original $m$ and a signature $\sigma^*$ such that $Verify(pk, m^*, \sigma^*)=1$.\\

The scheme is secure if no adversary can produce any forgery.\\

An OTS a signature scheme that is built using any OWF and assumes that the adversary $A$ can request a signature from the signing oracle ONLY ONCE.\\

\textbf{Theorem:} If $\Pi$ is EUF-CMA(Existential Unforgeability under Chosen Message Attack) then $\Pi$ is a secure OTS scheme.\\

\textbf{The Lamport Signature Scheme}\\\\
$f$ is an OWF.\\
for i$\gets$ 1 to l do\\\\
$x_{i0} \in \{0,1\}^n$\\
$x_{i1} \in \{0,1\}^n$\\\\
$y_{i0} \gets f(x_i,0)$\\
$y_{i1} \gets f(x_i,1)$\\\\
$s_k = \begin{pmatrix}
  x_{1,0} & x_{2,0} & \cdots & x_{l,0} \\
  x_{1,1} & x_{2,1} & \cdots & x_{l,1} \\
\end{pmatrix}$\\\\
$v_k = \begin{pmatrix}
  y_{1,0} & y_{2,0} & \cdots & y_{l,0} \\
  y_{1,1} & y_{2,1} & \cdots & y_{l,1} \\
\end{pmatrix}$\\\\
$Sign\begin{pmatrix}
  s_k, & m_1 & m_2 & \cdots & m_l \\
\end{pmatrix}=\begin{pmatrix}
  x_{1 m_1} & x_{2 m_2} & \cdots & x_{l m_l} \\
\end{pmatrix}$\\\\
$Verify\begin{pmatrix}
  v_k, & m_1 & m_2 & \cdots & m_l, & x_1 &x_2 & \cdots & x_l\\
\end{pmatrix}=\bigwedge^{n}_{i=1}f(x_i) == y_{i m_i}$\\

Breaking this signature would require for the adversary to invert the OWF.\\

However if the adversary can access the sign oracle more than once he would be able to breake it.

\chapter{Lecture 3}% 333333333333333333333333333333333333333333333333333333333333333333
\section{OTS - Proof of Security}

An OTS is unforgable if:\\
$Pr[Sig-forge^{1-time}_{A,\Pi}(n) = 1] \leq negl(n).$\\\\

\textbf{Theorem:} Let l be any polynomial. If f is an OWF, then $\Pi$ is a secure OTS scheme.

\textbf{Proof:}To prove this we will use reduction. We suppose that OTS is not secure, which means it can be broken by an adversary A that has the power to return one x (knowing the pk) in one point not known by the adversary B. We then build an adversary B who will use adversary A's break to invert OWF.

To help us understand the proof for the general case we will first go through two particular cases where we make the adversary A stronger.\\\\

Let $f(q)=w$ be a OWF.\\
Adversary A can find the $x_{i,b}$ for a given $y{i,b}$ with a \textbf{non-negligible} probability $\varepsilon$.
Adversary B knows $w$ and wants to find out $q$. B has access to A so all it has to do is to replace one of the original $ys$ with his $w$ and send the new $pk$ to A. A then returns $q$ which is the inverse of $w$, therefore inverting $f$.\\

\begin{enumerate}
\item \textbf{Adversary A can get all the $x_{i,0}$ given the public key.\\\\}
Adversary A knowing  $\begin{pmatrix}
  y_{1,0} & y_{2,0} & \cdots & y_{l,0} \\
  y_{1,1} & y_{2,1} & \cdots & y_{l,1} \\
\end{pmatrix}$ can find $\begin{pmatrix}
  x_{1,0} & x_{2,0} & \cdots & x_{l,0} \\
  . & . & \cdots & . \\
\end{pmatrix}$.\\\\\\
B sends $\begin{pmatrix}
  w & y_{2,0} & \cdots & y_{l,0} \\
  y_{1,1} & y_{2,1} & \cdots & y_{l,1} \\
\end{pmatrix}$ to A.\\\\
A returns $\begin{pmatrix}
  q & x_{2,0} & \cdots & x_{l,0} \\
  . & . & \cdots & . \\
\end{pmatrix}$ to B.\\\\\\
Therefore the probability of B inverting the OWF $f$ is $\varepsilon$.\\\\\\
\item \textbf{Adversary A returns randomly either $x_{1,0}$ or $x_{1,1}$. }\\
Adversary A knowing  $\begin{pmatrix}
  y_{1,0} & y_{2,0} & \cdots & y_{l,0} \\
  y_{1,1} & y_{2,1} & \cdots & y_{l,1} \\
\end{pmatrix}$ returns randomly one of the following: \\\\\\ $\begin{pmatrix}
  x_{1,0} & . & \cdots & . \\
  . & . & \cdots & . \\
\end{pmatrix}$ or $\begin{pmatrix}
  . & . & \cdots & . \\
  x_{1,1} & . & \cdots & . \\
\end{pmatrix}$.\\\\\\
B flips a coin and randomly sends to A one of the following:\\\\$\begin{pmatrix}
  w & y_{2,0} & \cdots & y_{l,0} \\
  y_{1,1} & y_{2,1} & \cdots & y_{l,1} \\
\end{pmatrix}$ or $\begin{pmatrix}
  y_{1,0}& y_{2,0} & \cdots & y_{l,0} \\
  w & y_{2,1} & \cdots & y_{l,1} \\
\end{pmatrix}$.\\\\\\
A randomly returns to B one of the following:\\\\$\begin{pmatrix}
  r & . & \cdots & . \\
  . & . & \cdots & . \\
\end{pmatrix}$ or $\begin{pmatrix}
  . & . & \cdots & . \\
  r & . & \cdots & . \\
\end{pmatrix}$.\\\\\\
The probability that $r=q$ and that B inverts $f$ is $\frac{\varepsilon}{2}$.
\end{enumerate}

\textbf{Now, for the general case,  we assume that adversary A can return randomly between $x_{i,0}$ or $x_{i,1}$, where $i$ is a random value.}\\

Adversary A knowing  $\begin{pmatrix}
  y_{1,0} & y_{2,0} & \cdots & y_{l,0} \\
  y_{1,1} & y_{2,1} & \cdots & y_{l,1} \\
\end{pmatrix}$ returns randomly one of the following:\\\\\\$\begin{pmatrix}
  . & . & \cdots & x_{i,0}& \cdots & . \\
  . & . & \cdots & . & \cdots & . \\
\end{pmatrix}$ or $\begin{pmatrix}
  . & . & \cdots & . & \cdots & . \\
  . & . & \cdots & x_{i,1}& \cdots & . \\
\end{pmatrix}$where $i$ is a random position.\\\\

Adversary B chooses a random position $j$ from $1$ to $l$, then flips a coin and randomly sends one of the following:\\\\ $\begin{pmatrix}
  y_{1,0} & y_{2,0} & \cdots w_j& \cdots& y_{l,0} \\
  y_{1,1} & y_{2,1} & \cdots y_{j,1}& \cdots& y_{l,1} \\
\end{pmatrix}$ or  $\begin{pmatrix}
  y_{1,0} & y_{2,0} & \cdots & y_{j,0} & \cdots& y_{l,0} \\
  y_{1,1} & y_{2,1} & \cdots & w_j & \cdots& y_{l,1} \\
\end{pmatrix}$.\\\\\\
The adversary A returns randomly one of the following:\\\\$\begin{pmatrix}
  . & . & \cdots & . & \cdots & . \\
  . & . & \cdots & r_{i,1}& \cdots & . \\
\end{pmatrix}$ or $\begin{pmatrix}
  . & . & \cdots & r_{i,0} & \cdots & . \\
  . & . & \cdots & .& \cdots & . \\
\end{pmatrix}$\\\\\\

The probability that $j$ is the same position as $i$ is $\frac{1}{l}$. The probability that \newline $(r=q) \wedge (i=j)$ is $\frac{1}{2l}$, Therefore the probability thet B inverts the OWF $f$ is $\frac{\varepsilon}{2l}$.\\\\
\textbf{Algorithm I:}\\
The algorithm is given $y$ and $1^n$ as input.
\begin{enumerate}
\item Choose random $i^*\gets\{1,\ldots,l\} \text{ and } b^*\gets\{0,1\}$. Set $y_{i^*,b^*} := y.$
\item For all $i\in\{1,\ldots, l\}$ and $b\in\{0,1\}$ with $(i,b)\not=(i^*,b^*):$ 
\begin{itemize}
\item Choose $x_{i,b}\gets\{0,1\}^n \text{ and set } y_{i,b}:=f(x_{i,b}).$
\end{itemize}
\item Run $A$ on input $pk:= \begin{pmatrix}
  y_{1,0} & y_{2,0} & \cdots & y_{l,0} \\
  y_{1,1} & y_{2,1} & \cdots & y_{l,1} \\
\end{pmatrix}$.
\item When $A$ requests a signature on the message $m'$:
\begin{itemize}
\item If $m'_{i^*}=b^*$, stop.
\item Otherwise, return the correct signature $\sigma = (x_{1,m'_1},\ldots,x_{l,m'_l}).$
\end{itemize}
\item When $A$ outputs $(m,\sigma)$ with $\sigma = (x_1,\ldots,x_p):$
\begin{itemize}
\item If $A$ outputs a forgery at $i^*, b^*)$, then output $x_{i^*}$.
\end{itemize}
\end{enumerate}

\section{Hard-Core Bits (HCB)}
Note: Hard-core bits are also called hard-core predicates.\\\\
By definition a OWF is hard to invert but that does not mean that we cannot learn \textbf{any} information about $f(x)$.\\\\
Let's consider a trivial example where $f(x)$ is an OWF.\\
Consider $g(x_1, x_2) = (x_1,f(x_2)) \text{ where } |x_1|=|x_2|$. It can be easily proven that $g$ is also an OWF even though it \textbf{reveals half of the input}.\\\\
The informal definition of a HCB:\\
\textbf{Definition 1:} $B\{0,1\}^n \rightarrow \{ 0,1 \}$\\
$B$ is a HCB for a function $f$ if given $f(x)$ you cannot figure out what $B(x)$ is.\\\\
The formal definition of a HCB:\\
\textbf{Definition 2:} A function $B\{0,1\}^n\rightarrow\{0,1\}$ is a HCB for a function $f$ if:
\begin{enumerate}
\item $B$ can be computed in polynomial time
\item for every probabilistic polynomial-time algorithm $A$ there exists a negligible function $negl$ such that:\\
$Prob[A(f(x))=B(x), x\gets\{0,1\}^n]\leq \frac{1}{2} + negl(n)$\\\\
Consider:
\begin{itemize}
\item $B(x_1,\ldots,x_n)=x_1 \oplus x_2 \oplus \ldots \oplus x_n$.\\
This example intuitively looks like a HCB. Because $f$ is an OWF and at least one of the bits should be hidden, you would think that computing $\bigoplus^n_{i=1}x_i$ would be impossible without inverting $f$. 
That is not true and we can prove it by defining $g(x)=(f(x), \bigoplus^n_{i=1}x_i)$ which is an OWF and clearly does not hide $B(x) = \bigoplus^n_{i=1}x_i$.\\ 
\end{itemize}
\end{enumerate}
\section{Goldreich and Levin Proof}

\textbf{Theorem:} If $f$ is an OWF then $\exists$ an OWF $gl$ and a HCB for $g$. If $f$ is a permutation the so is $g$.

$f:\{0,1\}^*\leftarrow\{0,1\}^*$\\\\
Define $g(x,R) = (f(x), R) \text{ where } |x| =|R|$\\
$B(x,R)= <x,R> =\bigoplus^n_{i=1}x_i \times R_i$\\
$B(x,R)$ is a HCB for $g$.\\\\
Example:
\begin{itemize}
\item $<1011,0110> = (1\times0)\oplus(0\times1)\oplus(1\times1)\oplus(1\times0)=0\oplus0\oplus1\oplus0=1$.
\end{itemize}
\chapter{Lecture 4}%444444444444444444444444444444444444444444444444444444444444444444444444
\section{Indistinguishability}
Randomness is very important in cryptography so that you cannot tell when the same message has been encrypted by looking at the cyphertexts.\\

\textbf{Definition 1:} Given X and Y distributions, we say that X and Y are computationaly indistinguishable if no efficient distinguisher can tell the distributions apart.\\\\
$[Prob_{z\gets X}[1\gets D(z)]-Prob_{z\gets Y}[1\gets D(Z)]]\leq negl(something*)$\\\\
We will ignore the definition of the \textit{something*}. What we can say about it for now is that it is the length of the key.\\\\
\textbf{Notation:} $X\sim Y$ means X is computationaly indistinguishable from Y.\\

Another definition of indistinguishability can be expressed in terms of HCB`s:\\
\textbf{Definition 2:} $B$ is a HCB for $f$.\\
Let:
\begin{itemize}
\item $X=(f(x), B(x)) \text{ with } x\xleftarrow{\$}\{0,1\}^n$
\item $Y=(f(x), b) \text{ with } x\xleftarrow{\$}\{0,1\}^n \text{ and } b\xleftarrow{\$}\{0,1\}^n$
\end{itemize}
Then $X\sim Y$.

\section{Exercises:}
\begin{itemize}
\item Prove that the two definitions above are equivalent
\end{itemize}
\newpage
\section{Pseudo-Random Generators (PRG`s)}

$G:\{0,1\}^n\rightarrow\{0,1\}^{f(n)}$, where $l(n)$ is some polynomial.
$G$ is a PRG if:
\begin{enumerate}
\item$n<l(n)$
\item $G(s) \sim U_{l(n)}$ where $s\xleftarrow{\$}\{0,1\}^n$ and $U_t$ is an uniform distribution on a bitstring of length $t$
\end{enumerate}
\textbf{Theorem:} Let $f$ be an One Way Permutation (OWP) and let B be a HCB for $f$.
Then the algorithm $G(s)=(f(s),B(s))$ is a PRG with $l(n)=n+1$.\\\\
\textbf{Proof:}
\chapter{Lecture 5}%5555555555555555555555555555555555555555555555555555555555555555
\section{Pseudo-Random Functions(PRF`s)}

%\chapter{Lecture 6}%6666666666666666666666666666666666666666666666666666666666666666
%\chapter{Lecture 7}%7777777777777777777777777777777777777777777777777777777777777777
%\chapter{Lecture 8}%8888888888888888888888888888888888888888888888888888888888888888

















\part{Problems Class Model Answers}
\section{Cryptography A}
\subsection{Problems Class 1}
Example slides...

\subsection{Problems Class 2}

\end{document}

