\chaptersub{Asymmetric Modes}{Public Key Cryptography}

\section{Introduction}

	The basic concept of public key cryptography is the idea of a box with two keys, a public key, and a private key. The \textbf{public key} allows anyone to \textbf{leave a message}. They cannot however read each others messages. The \textbf{private key} by contrast, allows its owner to \textbf{read any message left}. It is this asymmetry that gives the scheme its name.\\
	\\
	Or to put	it more concretely:\\
	\\
	\textbf{Message + \textcolor{B}{Public Key} = Ciphertext}\\
	\textbf{Ciphertext + \textcolor{R}{Private Key} = Message}\\

	Throughout this chapter, you will see a lot of colours. If you see \textcolor{R}{red}, the highlighted symbols are relevant to the \textcolor{R}{private key}. If you see \textcolor{B}{blue}, the highlighted symbols are relevant to the \textcolor{B}{public key}.

\section{Vanilla RSA}

	\subsection{Definition}

		RSA is actually very simple. Lets start with the encryption and decryption definitions, and work back from there.

		$$ c = m^{\textcolor{B}{e}} \bmod \textcolor{B}{N} $$

		$$ m = c^{\textcolor{R}{d}} \bmod \textcolor{B}{N} $$
		Simple right? $e$, $d$, and $N$ are the only things we need. So now lets cover just what these are.\\
		\\
	  \begin{tabularx}{\linewidth}{l l X}
	  \textbf{Symbol} & \textbf{Maths}\footnote{Any unfamiliar symbols or functions are described in the Mathematics section.} & \textbf{Notes}\\
	  $\textcolor{B}{N}$ & $\textcolor{B}{N} = \textcolor{R}{p} * \textcolor{R}{q}$ & Where $p$ and $q$ are two massive \textbf{prime} numbers.
	  \\
	  $\textcolor{B}{e}$ & $\gcd(\textcolor{B}{e},\phi(\textcolor{B}{N}))=1$ & A randomly chosen integer, where $1 < \textcolor{B}{e} < \phi(\textcolor{B}{N})$.
	  \\
	  $\textcolor{R}{d}$ & $\textcolor{B}{e}*\textcolor{R}{d} = 1 \mod \phi(\textcolor{B}{N})$ & Computed using the XGCD algorithm.
	  \\
	  \end{tabularx}
	  
	It is worth proving that this system works, namely that decrpyting a ciphertext will always result in the original message.

	\vspace{5mm}
	
	Let $c = enc(m)$, and let $x = dec(c)$. We intend to prove that $x \cong m \mod N$. The system is obviously correct (and obviously insecure) in the case where $c=m=0$, so suppose this is not the case. We have that
	
	\begin{align*}
	    x &\cong m^{\blue{e}\red{d}} \mod \blue{N}\\
	    x &\cong m^{\blue{e}\red{d}} \mod \red{p}\\
	    x &\cong m^{\blue{e}\red{d}} \mod \red{q}
	\end{align*}
	
	Consider $x \cong m^{\blue{e}\red{d}} \mod \red{p}$. Since $m \neq 0$, we can invoke Fermat's Little Theorem to conclude that
	
	$$
	    m^{\blue{e}\red{d}} \cong m^{\blue{e}\red{d} \mod (\red{p}-1)} \mod \red{p}
	$$
	
	Since $\blue{e}\red{d} \cong 1 \mod (\red{p}-1)(\red{q}-1)$, we have that, for some integer $k$, $\blue{e}\red{d} = 1 + k(\red{p}-1)(\red{q}-1)$, hence $\blue{e}\red{d} \cong 1 \mod (\red{p}-1)$. Therefore
	
	$$
	    m^{\blue{e}\red{d} \mod (\red{p}-1)}\cong m^1 \mod \red{p}
	$$
	
	So $x \cong m \mod \red{p}$. Nearly identical reasoning allows us to conclude that $x \cong m \mod \red{q}$. By the Chinese Remainder Theorem, it must therefore be the case that $x \cong m \mod N$, and hence
	
	$$
	    dec(enc(m)) \cong m \mod N 
	$$
	
	\begin{flushright}
	QED
	\end{flushright}
	\subsection{Security}

		Vanilla RSA is \textbf{OW-CPA} under the assumption that the RSA problem is hard. If we could easily break vanilla RSA with a \textbf{OW-CPA}, then we could use this attack to easily solve the RSA problem. Since we assumed that we cannot easily solve the RSA problem, it must be the case that we cannot mount a \textbf{OW-CPA} attack against vanilla RSA.\\
		\\
		It is however \textbf{not IND-CPA} secure. This is pretty obvious; the encryption function is deterministic, so when given a ciphertext from a set of two messages, we can simply encrypt one message from the set, and know that if it does not match the ciphertext we received, we must have been sent the other message.\\
		\\
		An encryption scheme is considered \textbf{malleable} if given $c_1$, the ciphertext of $m_1$, we can compute another valid ciphertext $c'$, from a message mathematically related to $m_1$. This is indeed the case with RSA, for instance given two ciphertexts $c_1$ and $c_2$, we could compute:
		$$c_3 = c_1*c_2 \mod N = (m_1 * m_2)^e \mod N$$ 
		Without ever knowing $m_1$ or $m_2$! This is not a good thing.\footnote{Unless you do Applied Security, in which case this was what you used to perform the RSA-OAEP attack successfully.} Why not? Because if you encrypt the number 100, without knowing that, or the private key, I can create a valid ciphertext for the number 200, simply by encrypting $m = 2$ and multiplying our ciphertexts together, modulo $N$.\\
		\\
		Due to this malleability, vanilla RSA is \textbf{not OW-CCA} secure. Recall in a CCA we are allowed to decrypt any ciphertext \textit{besides the target ciphertext}. However, we now know how to manipulate the ciphertext while leaving the original message relatively unharmed. As such, to recover $m$, we simply compute $c' = c*2^e \mod N$, then decrypt $c'$, giving $m' = m * 2$. Recovering $m$ is now trivial.


\section{Signatures}



\section{Hybrid Encryption}

\section{Key Encapsulation}

\section{Padding Schemes}

	\subsection{Introduction}
		A padding scheme in its simplest form is a system to ensure that when our block size does not exactly divide our message, we do not lose data, or gain data that was not in our message (i.e. we are able to distinguish padding from our original message body).\\
		\\
		A padding scheme generally uses a block at either the beginning or start of the message to specify the length of the message body, potentially along with additional information, such as a hash to verify message authenticity.

	\subsection{OAEP}
		Optical Asymmetric Encryption Padding is one such padding scheme. \textit{Incredibly simplified}\footnote{Seriously this is so simplified it is only for ones intuitive understanding of why it is effective} the scheme pads a message with a --- generally SHA1 --- hash of the message body. If after decryption the hash is not correct for this message body, we know the message is invalid. OAEP goes above and beyond this, but that's the gist of it.\\
		\\
		When used with RSA, OAEP gives a scheme which is \textbf{IND-CCA} secure.


\section{Rabin}
	Rabin encryption is a public key cryptography scheme that is provably more secure than RSA. Its security is based on the difficulty of the SQROOT problem, which is provably equal in difficulty to the FACTORING problem. By contrast, the RSA problem, while assumed to be hard, has not been proven to be hard.\\
	\\
	Our private key is made up of two components, $\textcolor{R}{p}$ and $\textcolor{R}{q}$, two similarly sized prime numbers where $\textcolor{R}{p} = \textcolor{R}{q} = 3 \mod 4$.\footnote{This just makes extracting roots fast, there is no cryptographic need for this.}\\
	\\
	Our public key is made up of two components as well, $\textcolor{B}{N} = \textcolor{R}{p}*\textcolor{R}{q}$ and $\textcolor{B}{B}$. $\textcolor{B}{B}$ is a randomly chosen number between $0$ and $\textcolor{B}{N}$\\
  \begin{figure}[htp!]
		$$c = m * (m + \textcolor{B}{B}) \mod \textcolor{B}{N}$$
  \caption{Rabin Encryption Algorithm}
  \label{fig:rabin-enc}
  \end{figure}

  \begin{figure}[htp!]
		$$m = \sqrt{\frac{\textcolor{B}{B}^2}{4}+c} - \frac{\textcolor{B}{B}}{2} \mod \textcolor{B}{N}$$
  \caption{Rabin Decryption Algorithm}
  \label{fig:rabin-dec}
  \end{figure}
	An interesting property of the Rabin scheme, as seen in Figure~\ref{fig:rabin-dec}, the private key is not strictly speaking needed for decryption, however in reality this is a case of the SQROOT problem; even knowing the contents of the square root, finding the square root is not a trivial task.\\
	\\
	This is where the private key comes in. Lets focus on the portion of the equation that is hard to solve:
	$$t = \frac{\textcolor{B}{B}^2}{4}+c$$
	We instead now solve $\sqrt{t} = \pm x\mod p $ and $\sqrt{t} = \pm y \mod q$. The final step is to make use of the CRT to solve $\mod N$. % TODO: I'm stopping here because at this point I'm lost. - Matt


\section{ElGamal}