\chaptersub{Asymmetric Modes}{Public Key Cryptography}

\section{Introduction}

	The basic concept of public key cryptography is the idea of a box with two keys, a public key, and a private key. The \textbf{public key} allows anyone to \textbf{leave a message}. They cannot however read each others messages. The \textbf{private key} by contrast, allows its owner to \textbf{read any message left}. It is this asymmetry that gives the scheme its name.\\
	\\
	Or to put	it more concretely:\\
	\\
	\textbf{Message + \textcolor{B}{Public Key} = Ciphertext}\\
	\textbf{Ciphertext + \textcolor{R}{Private Key} = Message}\\

	Throughout this chapter, you will see a lot of colours. If you see \textcolor{R}{red}, the highlighted symbols are relevant to the \textcolor{R}{private key}. If you see \textcolor{B}{blue}, the highlighted symbols are relevant to the \textcolor{B}{public key}.

\section{Vanilla RSA}

	\subsection{Definition}

		RSA is actually very simple. Lets start with the encryption and decryption definitions, and work back from there.

		$$ \cc = \cm^{\ce} \bmod \cN $$

		$$ \cm = \cc^{\cd} \bmod \cN $$
		Simple right? $\ce$, $\cd$, and $\cN$ are the only things we need. So now lets cover just what these are.\\
		\\
	  \begin{tabularx}{\linewidth}{l l X}
		  \textbf{Symbol} & \textbf{Maths}\footnote{Any unfamiliar symbols or functions are described in the Mathematics section.} & \textbf{Notes}\\
		  $\textcolor{B}{N}$ & $\cN = \cp * \cq$ & Where $\cp$ and $\cq$ are two massive \textbf{prime} numbers.
		  \\
		  $\ce$ & $\gcd(\ce,\phi(\cN))=1$ & A randomly chosen integer, where $1 < \ce < \phi(\cN)$.
		  \\
		  $\cd$ & $\ce*\cd = 1 \mod \phi(\cN)$ & Computed using the XGCD algorithm.
		  \\
	  \end{tabularx}
	  
	It is worth proving that this system works, namely that decrpyting a ciphertext will always result in the original message.

	\vspace{5mm}
	
	Let $\cc = enc(\cm)$, and let $x = dec(\cc)$. We intend to prove that $x \cong \cm \mod \cN$. The system is obviously correct (and obviously insecure) in the case where $\cc=\cm=0$, so suppose this is not the case. We have that
	
	\begin{align*}
	    x &\cong \cm^{\ce\cd} \mod \cN\\
	    x &\cong \cm^{\ce\cd} \mod \cp\\
	    x &\cong \cm^{\ce\cd} \mod \cq
	\end{align*}
	
	Consider $x \cong \cm^{\ce}\cd \mod \cp$. Since $\cm \neq 0$, we can invoke Fermat's Little Theorem to conclude that
	
	$$
	    \cm^{\ce\cd} \cong \cm^{\ce\cd \mod (\cp-1)} \mod \cp
	$$
	
	Since $\ce\cd \cong 1 \mod (\cp-1)(\cq-1)$, we have that, for some integer $k$, $\ce\cd = 1 + \ck(\cp-1)(\cq-1)$, hence $\ce\cd \cong 1 \mod (\cp-1)$. Therefore
	
	$$
	    \cm^{\ce\cd \mod (\cp-1)}\cong \cm^1 \mod \cp
	$$
	
	So $x \cong \cm \mod \cp$. Nearly identical reasoning allows us to conclude that $x \cong \cm \mod \cq$. By the Chinese Remainder Theorem, it must therefore be the case that $x \cong \cm \mod \cN$, and hence
	
	$$
	    dec(enc(\cm)) \cong \cm \mod \cN 
	$$
	
	\begin{flushright}
	QED
	\end{flushright}
	\subsection{Security}

		Vanilla RSA is \textbf{OW-CPA} under the assumption that the RSA problem is hard. If we could easily break vanilla RSA with a \textbf{OW-CPA}, then we could use this attack to easily solve the RSA problem. Since we assumed that we cannot easily solve the RSA problem, it must be the case that we cannot mount a \textbf{OW-CPA} attack against vanilla RSA.\\
		\\
		It is however \textbf{not IND-CPA} secure. This is pretty obvious; the encryption function is deterministic, so when given a ciphertext from a set of two messages, we can simply encrypt one message from the set, and know that if it does not match the ciphertext we received, we must have been sent the other message.\\
		\\
		An encryption scheme is considered \textbf{malleable} if given $\csubc{1}$, the ciphertext of $\csubm{1}$, we can compute another valid ciphertext $c'$, from a message mathematically related to $\csubm{1}$. This is indeed the case with RSA, for instance given two ciphertexts $\csubc{1}$ and $\csubc{2}$, we could compute:
		$$\csubc{3} = \csubc{1}*\csubc{2} \mod N = (\csubm{1} * \csubm{2})^\ce \mod \cN$$ 
		Without ever knowing $\csubm{1}$ or $\csubm{2}$! This is not a good thing.\footnote{Unless you do Applied Security, in which case this was what you used to perform the RSA-OAEP attack successfully.} Why not? Because if you encrypt the number 100, without knowing that, or the private key, I can create a valid ciphertext for the number 200, simply by encrypting $m = 2$ and multiplying our ciphertexts together, modulo $N$.\\
		\\
		Due to this malleability, vanilla RSA is \textbf{not OW-CCA} secure. Recall in a CCA we are allowed to decrypt any ciphertext \textit{besides the target ciphertext}. However, we now know how to manipulate the ciphertext while leaving the original message relatively unharmed. As such, to recover $\cm$, we simply compute $c' = \cc*2^e \mod N$, then decrypt $c'$, giving $m' = \cm * 2$. Recovering $\cm$ is now trivial.


\section{Signatures}



\section{Hybrid Encryption}
	A hybrid scheme is one which makes use of both symmetric and asymmetric encryption schemes. Generally, an asymmetric system is used to transmit a symmetric key which is then used to send messages.\\

	\subsection{Key Encapsulation Mechanism - KEM}
		Key encapsulation refers to how we use an asymmetric encryption (or public key) scheme to send the key used to send data to a recipient securely. The formal definition is as follows:
		\begin{center}
			$KEM(\cpk) = (\cK,\cc)$\\
			$KEM^{-1}(\cc, \csk) = \cK$ \quad if $\cc$ is an encapsulation of $\cK$, else $\bot$.
		\end{center}

	\subsection{Data Encapsulation Mechanism - DEM}
		Data encapsulation refers to how we use a symmetric encryption scheme to send data to a recipient securely. They are generally based on a block cipher since this allows the data to be of variable length. The formal definition is as follows:
		\begin{center}
			$DEM(\cm,\cK) = \cc$ \quad where $\cK$ is a key for the symmetric key function.\\
			$DEM^{-1}(\cc,\ck) = \cm $ \quad if decryption is successful, else $\bot$.
		\end{center}


\section{Padding Schemes}

	\subsection{Introduction}
		A padding scheme in its simplest form is a system to ensure that when our block size does not exactly divide our message, we do not lose data, or gain data that was not in our message (i.e. we are able to distinguish padding from our original message body).\\
		\\
		A padding scheme generally uses a block at either the beginning or start of the message to specify the length of the message body, potentially along with additional information, such as a hash to verify message authenticity.

	\subsection{OAEP}
		Optical Asymmetric Encryption Padding is one such padding scheme. \textit{Incredibly simplified}\footnote{Seriously this is so simplified it is only for ones intuitive understanding of why it is effective} the scheme pads a message with a --- generally SHA1 --- hash of the message body. If after decryption the hash is not correct for this message body, we know the message is invalid. OAEP goes above and beyond this, but that's the gist of it.\\
		\\
		When used with RSA, OAEP gives a scheme which is \textbf{IND-CCA} secure.


\section{Rabin}
	Rabin encryption is a public key cryptography scheme that is provably more secure than RSA. Its security is based on the difficulty of the SQROOT problem, which is provably equal in difficulty to the FACTORING problem. By contrast, the RSA problem, while assumed to be hard, has not been proven to be hard.\\
	\\
	Our private key is made up of two components, $\textcolor{R}{p}$ and $\textcolor{R}{q}$, two similarly sized prime numbers where $\textcolor{R}{p} = \textcolor{R}{q} = 3 \mod 4$.\footnote{This just makes extracting roots fast, there is no cryptographic need for this.}\\
	\\
	Our public key is made up of two components as well, $\textcolor{B}{N} = \textcolor{R}{p}*\textcolor{R}{q}$ and $\textcolor{B}{B}$. $\textcolor{B}{B}$ is a randomly chosen number between $0$ and $\textcolor{B}{N}$\\
  \begin{figure}[htp!]
		$$c = m * (m + \textcolor{B}{B}) \mod \textcolor{B}{N}$$
  \caption{Rabin Encryption Algorithm}
  \label{fig:rabin-enc}
  \end{figure}

  \begin{figure}[htp!]
		$$m = \sqrt{\frac{\textcolor{B}{B}^2}{4}+c} - \frac{\textcolor{B}{B}}{2} \mod \textcolor{B}{N}$$
  \caption{Rabin Decryption Algorithm}
  \label{fig:rabin-dec}
  \end{figure}
	An interesting property of the Rabin scheme, as seen in Figure~\ref{fig:rabin-dec}, the private key is not strictly speaking needed for decryption, however in reality this is a case of the SQROOT problem; even knowing the contents of the square root, finding the square root is not a trivial task.\\
	\\
	This is where the private key comes in. Lets focus on the portion of the equation that is hard to solve:
	$$t = \frac{\textcolor{B}{B}^2}{4}+c$$
	We instead now solve $\sqrt{t} = \pm x\mod p $ and $\sqrt{t} = \pm y \mod q$. The final step is to make use of the CRT to solve $\mod N$. Recall that using CRT we have the equation as follows, with as yet unknowns highlighted:

	$$ t \mod N = (\mathbf{a_1} p \mathbf{y_1}) + (\mathbf{a_2} q \mathbf{y_2}) \mod N $$
	Fortunately these are easy enough to find. % TODO: BUT HOW LOL. - Matt


\section{ElGamal}

	\subsection{The Diffie-Hellman Problems}

	There are, in fact, two Diffie-Hellman problems, a computational one and a decisional one. Let $g$ be a generator for some group, and let $x, y$ and $z$ be integers. In the Computational Diffie-Hellman problem, you are given $g$, $g^x$ and $g^y$, and must compute $g^xy$. For the decisional diffie-hellman problem, you are given $g$, $g^x$, $g^y$ and $g^z$, and are required to decide if $z=xy$. ElGamal is an encryption scheme built on the assumption that both of these problems are hard.

	\subsection{The Algorithms}

	Let $\blue{p}$ be some large prime, usually around 1024-bits. Let $\blue{q}$ be another prime, usually around 160-bits, such that $\blue{q}$ divides $\blue{p}-1$. Compute $\blue{g}$, a generator of a multiplicative group of order $\blue{q}$ -- usually the group of positive integers modulo $q$ under multiplication. $\blue{(p,q,g)}$ are the public domain parameters of the ElGamal scheme, and are part of the public key.\\
\\
	Now let $1 \leqslant \red{x} < \blue{q}$ be some random integer, and let
	$$
		\blue{h} \cong \blue{g}^\red{x} \mod \blue{p}
	$$
	$\blue{h}$ is the ElGamal public key, and $\red{x}$ is the private key.\\
\\
	To encrypt some message, $\red{m}$, pick some random integer $1 \leqslant k < \blue{q}$, and compute
	\begin{align*}
		\blue{c_1} &\cong \blue{g}^\red{k} \mod \blue{p}\\
		\blue{c_2} &\cong \red{m}\blue{h}^\red{k} \mod \blue{p}
	\end{align*}
	And send $\blue{c = (c_1,c_2)}$.\\
\\
	To decrypt some ciphertext, $\blue{(c_1,c_2)}$, compute
	$$
		\red{m} \cong \blue{c_1}^{-\red{x}}\blue{c_2} \mod \blue{p}
	$$
	The proof that this decryption works is somewhat simpler than it was for ElGamal. Expand all ciphertexts to their definitions to see that $\blue{c_1} \cong \blue{g}^\red{k}$ and $\blue{c_2} \cong \red{m}\blue{g}^{\red{xk}}$, and note that
	\begin{align*}
		 \blue{c_1}^{-\red{x}}\blue{c_2}
	&\cong (\blue{g}^\red{k})^{-\red{x}}\red{m}\blue{g}^\red{xk} \mod \blue{p} \\
	&\cong \blue{g}^{\red{xk}}\blue{g}^{-\red{xk}}\red{m} \mod \blue{p} \\
	&\cong \red{m} \mod \blue{p}
	\end{align*}
	So decryption inverts encryption.\\\vspace{5mm}
\\
	ElGamal is OW-CPA under the assumption that the Computational Diffie Hellman problem is hard. Proving this is a little more difficult than with RSA, so pay attention.\\
\\
	Suppose there exists some adversary against ElGamal encryption. Given only public information, ie the domain parameters and a ciphertext, this adversary will recover the message within the cipher. We intend to exploit this adversary to solve the Computational Diffie Hellman problem, that is send it $g^x$ and $g^y$, and somehow recover $g^xy$.\\
\\
	Let $h$, the public key, be equal to $g^x$. Choose $c_1 = g^y$ and $c_2 = 1$. This is entirely valid, since the oracle must account for whatever random number, $k$, the encryption process chooses. If $c_1 = g^y$, then it must be the case that $k=y$. If $c_2=1$, it must be the case that $mg^{xy} = 1$. Hence the oracle must return $m \cong g^{-xy} \mod p$. Finding the modular inverse of $m$ is certainly slow, but is not computationally hard, hence $m^{-1} \cong g^{xy} \mod p$, and we have easily solved the Computational Diffie Hellman problem.\\
\\
	This gives us a contradiction, since the Computational Diffie Hellman problem is hard, so the supposed OW-CPA adversary against ElGamal cannot exist.
\begin{flushright}
QED
\end{flushright}
